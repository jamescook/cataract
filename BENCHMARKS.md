<!-- AUTO-GENERATED FILE - DO NOT EDIT -->
<!-- This file is automatically generated from benchmark results. -->
<!-- To regenerate: rake benchmark:generate_docs -->

# Performance Benchmarks

Comprehensive performance comparison between Cataract and css_parser gem.

## Test Environment

- **Ruby**: ruby 3.4.5 (2025-07-16 revision 20cda200d3) +YJIT +PRISM [arm64-darwin23]
- **CPU**: Apple M1 Pro
- **Memory**: 32GB
- **OS**: macOS 14.5
- **Generated**: 2025-10-30T16:01:15-05:00

<details>
<summary><h2>CSS Parsing</h2></summary>

Performance of parsing CSS into internal data structures.

Time to parse CSS into internal data structures

### Small CSS (64 lines, 1.0KB)


| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | 6.27K i/s | 159.47 μs |
| **Cataract** | **65.25K i/s** | **15.33 μs** |
| **Speedup** | **10.41x faster** | |

### Medium CSS with @media (139 lines, 1.6KB)


| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | 3.29K i/s | 303.61 μs |
| **Cataract** | **42.52K i/s** | **23.52 μs** |
| **Speedup** | **12.91x faster** | |


</details>

---

<details>
<summary><h2>CSS Serialization (to_s)</h2></summary>

Performance of converting parsed CSS back to string format.

Time to convert parsed CSS back to string format

### Full Serialization (Bootstrap CSS - 191KB)


| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | 34.0 i/s | 29.41 ms |
| **Cataract** | **714.8 i/s** | **1.4 ms** |
| **Speedup** | **21.02x faster** | |

### Media Type Filtering (print only)


| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | 4.06K i/s | 246.56 μs |
| **Cataract** | **232.22K i/s** | **4.31 μs** |
| **Speedup** | **57.26x faster** | |


</details>

---

<details>
<summary><h2>Specificity Calculation</h2></summary>

Performance of calculating CSS selector specificity values.

Time to calculate CSS selector specificity values

| Test Case | Speedup |
|-----------|---------|
| Simple Selectors | **22.03x faster** |
| Compound Selectors | **30.55x faster** |
| Combinators | **28.34x faster** |
| Pseudo-classes & Pseudo-elements | **46.06x faster** |
| :not() Pseudo-class (CSS3) | **23.64x faster** |
| Complex Real-world Selectors | **49.17x faster** |

**Summary:** 22.03x faster to 49.17x faster (avg 33.3x faster)

</details>

---

<details>
<summary><h2>CSS Merging</h2></summary>

Performance of merging multiple CSS rule sets with the same selector.

Time to merge multiple CSS rule sets with same selector

| Test Case | Speedup |
|-----------|---------|
| No shorthand properties (large) | **3.34x faster** |
| Simple properties | **3.42x faster** |
| Cascade with specificity | **5.19x faster** |
| Important declarations | **5.37x faster** |
| Shorthand expansion | **3.65x faster** |
| Complex merging | **2.65x faster** |

**Summary:** 2.65x faster to 5.37x faster (avg 3.94x faster)

### What's Being Tested
- Specificity-based CSS cascade (ID > class > element)
- `!important` declaration handling
- Shorthand property expansion (e.g., `margin` → `margin-top`, `margin-right`, etc.)
- Shorthand property creation from longhand properties

</details>

---

<details>
<summary><h2>YJIT Impact</h2></summary>

Impact of Ruby's YJIT JIT compiler on Ruby-side operations. The C extension performance is the same regardless of YJIT.

Ruby-side operations with and without YJIT

### Operations Per Second

| Operation | Without YJIT | With YJIT | YJIT Improvement |
|-----------|--------------|-----------|------------------|
| property access | 227.18K i/s | 322.32K i/s | **1.42x faster** (42% faster) |
| declaration merging | 204.26K i/s | 337.81K i/s | **1.65x faster** (65% faster) |
| to_s generation | 242.66K i/s | 391.16K i/s | **1.61x faster** (61% faster) |
| parse + iterate | 121.52K i/s | 142.77K i/s | **1.17x faster** (17% faster) |

### Key Takeaways
- YJIT provides significant performance boost for Ruby-side operations
- Greatest impact on declaration merging
- Parse + iterate benefits least since most work is in C
- Recommended: Enable YJIT in production (`--yjit` flag or `RUBY_YJIT_ENABLE=1`)

</details>

---

## Summary

### Performance Highlights

| Category | Min Speedup | Max Speedup | Avg Speedup |
|----------|-------------|-------------|-------------|
| **Parsing** | 10.41x faster | 12.91x faster | 11.66x faster |
| **Serialization** | 21.02x faster | 57.26x faster | 39.14x faster |
| **Specificity** | 22.03x faster | 49.17x faster | 33.3x faster |
| **Merging** | 2.65x faster | 5.37x faster | 3.94x faster |

### Implementation Notes

1. **C Extension**: Critical paths (parsing, specificity, merging, serialization) implemented in C
2. **Efficient Data Structures**: Rules grouped by media query for O(1) lookups
3. **Memory Efficient**: Pre-allocated string buffers, minimal Ruby object allocations
4. **Optimized Algorithms**: Purpose-built CSS specificity calculator

### Use Cases

- **Large CSS files**: Handles complex stylesheets efficiently
- **Specificity calculations**: Optimized for selector analysis
- **High-volume processing**: Reduced allocations minimize GC pressure
- **Production applications**: Tested with Bootstrap CSS and real-world stylesheets

---

## Running Benchmarks

```bash
# All benchmarks
rake benchmark 2>&1 | tee benchmark_output.txt

# Individual benchmarks
rake benchmark:parsing
rake benchmark:serialization
rake benchmark:specificity
rake benchmark:merging
rake benchmark:yjit

# Generate documentation
rake benchmark:generate_docs
```

## Notes

- All benchmarks use benchmark-ips with 3s warmup and 5-10s measurement periods
- Measurements are median i/s (iterations per second) with standard deviation
- css_parser gem must be installed for comparison benchmarks
