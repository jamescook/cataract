<!-- AUTO-GENERATED FILE - DO NOT EDIT -->
<!-- This file is automatically generated from benchmark results. -->
<!-- To regenerate: rake benchmark:generate_docs -->

# Performance Benchmarks

Comprehensive performance comparison between Cataract and css_parser gem.

## Test Environment

- **Ruby**: <%= metadata['ruby_description'] %>
- **CPU**: <%= metadata['cpu'] %>
- **Memory**: <%= metadata['memory'] %>
- **OS**: <%= metadata['os'] %>
- **Generated**: <%= metadata['timestamp'] %>

<%- if parsing_data -%>
<details>
<summary><h2>CSS Parsing</h2></summary>

Performance of parsing CSS into internal data structures.

<%= parsing_data['description'] %>

<%- parsing_data['metadata']['test_cases'].each do |test_case| -%>
### <%= test_case['name'] %>

<%- results = parsing_data['results'].select { |r| r['name'].include?(test_case['fixture']) } -%>
<%- css_parser_result = results.find { |r| r['name'].include?('css_parser') } -%>
<%- cataract_result = results.find { |r| r['name'].include?('cataract') } -%>
<%- if css_parser_result && cataract_result -%>
<%- speedup = cataract_result['central_tendency'] / css_parser_result['central_tendency'] -%>

| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | <%= format_ips(css_parser_result, short: true) %> | <%= format_time_per_op(css_parser_result) %> |
| **Cataract** | **<%= format_ips(cataract_result, short: true) %>** | **<%= format_time_per_op(cataract_result) %>** |
| **Speedup** | **<%= format_speedup(speedup) %>** | |

<%- end -%>
<%- end -%>

</details>

---
<%- end -%>

<%- if serialization_data -%>
<details>
<summary><h2>CSS Serialization (to_s)</h2></summary>

Performance of converting parsed CSS back to string format.

<%= serialization_data['description'] %>

<%- serialization_data['metadata']['test_cases'].each do |test_case| -%>
### <%= test_case['name'] %>

<%- results = serialization_data['results'].select { |r| r['name'].include?(test_case['key']) } -%>
<%- css_parser_result = results.find { |r| r['name'].include?('css_parser') } -%>
<%- cataract_result = results.find { |r| r['name'].include?('cataract') } -%>
<%- if css_parser_result && cataract_result -%>
<%- speedup = cataract_result['central_tendency'] / css_parser_result['central_tendency'] -%>

| Parser | Speed | Time per operation |
|--------|-------|-------------------|
| css_parser | <%= format_ips(css_parser_result, short: true) %> | <%= format_time_per_op(css_parser_result) %> |
| **Cataract** | **<%= format_ips(cataract_result, short: true) %>** | **<%= format_time_per_op(cataract_result) %>** |
| **Speedup** | **<%= format_speedup(speedup) %>** | |

<%- end -%>
<%- end -%>

</details>

---
<%- end -%>

<%- if specificity_data -%>
<details>
<summary><h2>Specificity Calculation</h2></summary>

Performance of calculating CSS selector specificity values.

<%= specificity_data['description'] %>

| Test Case | Speedup |
|-----------|---------|
<%- specificity_data['metadata']['test_cases'].each do |test_case| -%>
| <%= test_case['name'] %> | **<%= format_speedup(test_case['speedup']) %>** |
<%- end -%>

**Summary:** <%= format_speedup(specificity_data['metadata']['speedups']['min']) %> to <%= format_speedup(specificity_data['metadata']['speedups']['max']) %> (avg <%= format_speedup(specificity_data['metadata']['speedups']['avg']) %>)

</details>

---
<%- end -%>

<%- if merging_data -%>
<details>
<summary><h2>CSS Merging</h2></summary>

Performance of merging multiple CSS rule sets with the same selector.

<%= merging_data['description'] %>

| Test Case | Speedup |
|-----------|---------|
<%- merging_data['metadata']['test_cases'].each do |test_case| -%>
| <%= test_case['name'] %> | **<%= format_speedup(test_case['speedup']) %>** |
<%- end -%>

**Summary:** <%= format_speedup(merging_data['metadata']['speedups']['min']) %> to <%= format_speedup(merging_data['metadata']['speedups']['max']) %> (avg <%= format_speedup(merging_data['metadata']['speedups']['avg']) %>)

### What's Being Tested
- Specificity-based CSS cascade (ID > class > element)
- `!important` declaration handling
- Shorthand property expansion (e.g., `margin` â†’ `margin-top`, `margin-right`, etc.)
- Shorthand property creation from longhand properties

</details>

---
<%- end -%>

<%- if yjit_data -%>
<details>
<summary><h2>YJIT Impact</h2></summary>

Impact of Ruby's YJIT JIT compiler on Ruby-side operations. The C extension performance is the same regardless of YJIT.

<%= yjit_data['description'] %>

### Operations Per Second

| Operation | Without YJIT | With YJIT | YJIT Improvement |
|-----------|--------------|-----------|------------------|
<%- yjit_data['metadata']['operations'].each do |operation| -%>
<%- results = yjit_data['results'].select { |r| r['name'].include?(operation) } -%>
<%- no_yjit = results.find { |r| r['name'].include?('no YJIT') } -%>
<%- with_yjit = results.find { |r| r['name'].include?('YJIT') && !r['name'].include?('no YJIT') } -%>
<%- if no_yjit && with_yjit -%>
<%- improvement = with_yjit['central_tendency'] / no_yjit['central_tendency'] -%>
<%- pct = ((improvement - 1) * 100).round -%>
| <%= operation %> | <%= format_ips(no_yjit, short: true) %> | <%= format_ips(with_yjit, short: true) %> | **<%= format_speedup(improvement) %>** (<%= pct %>% faster) |
<%- end -%>
<%- end -%>

### Key Takeaways
- YJIT provides significant performance boost for Ruby-side operations
- Greatest impact on declaration merging
- Parse + iterate benefits least since most work is in C
- Recommended: Enable YJIT in production (`--yjit` flag or `RUBY_YJIT_ENABLE=1`)

</details>

---
<%- end -%>

## Summary

### Performance Highlights

| Category | Min Speedup | Max Speedup | Avg Speedup |
|----------|-------------|-------------|-------------|
<%- if parsing_data && parsing_data['metadata']['speedups'] -%>
<%- sp = parsing_data['metadata']['speedups'] -%>
| **Parsing** | <%= format_speedup(sp['min']) %> | <%= format_speedup(sp['max']) %> | <%= format_speedup(sp['avg']) %> |
<%- end -%>
<%- if serialization_data && serialization_data['metadata']['speedups'] -%>
<%- sp = serialization_data['metadata']['speedups'] -%>
| **Serialization** | <%= format_speedup(sp['min']) %> | <%= format_speedup(sp['max']) %> | <%= format_speedup(sp['avg']) %> |
<%- end -%>
<%- if specificity_data && specificity_data['metadata']['speedups'] -%>
<%- sp = specificity_data['metadata']['speedups'] -%>
| **Specificity** | <%= format_speedup(sp['min']) %> | <%= format_speedup(sp['max']) %> | <%= format_speedup(sp['avg']) %> |
<%- end -%>
<%- if merging_data && merging_data['metadata']['speedups'] -%>
<%- sp = merging_data['metadata']['speedups'] -%>
| **Merging** | <%= format_speedup(sp['min']) %> | <%= format_speedup(sp['max']) %> | <%= format_speedup(sp['avg']) %> |
<%- end -%>

### Implementation Notes

1. **C Extension**: Critical paths (parsing, specificity, merging, serialization) implemented in C
2. **Efficient Data Structures**: Rules grouped by media query for O(1) lookups
3. **Memory Efficient**: Pre-allocated string buffers, minimal Ruby object allocations
4. **Optimized Algorithms**: Purpose-built CSS specificity calculator

### Use Cases

- **Large CSS files**: Handles complex stylesheets efficiently
- **Specificity calculations**: Optimized for selector analysis
- **High-volume processing**: Reduced allocations minimize GC pressure
- **Production applications**: Tested with Bootstrap CSS and real-world stylesheets

---

## Running Benchmarks

```bash
# All benchmarks
rake benchmark 2>&1 | tee benchmark_output.txt

# Individual benchmarks
rake benchmark:parsing
rake benchmark:serialization
rake benchmark:specificity
rake benchmark:merging
rake benchmark:yjit

# Generate documentation
rake benchmark:generate_docs
```

## Notes

- All benchmarks use benchmark-ips with 3s warmup and 5-10s measurement periods
- Measurements are median i/s (iterations per second) with standard deviation
- css_parser gem must be installed for comparison benchmarks
